# PLAN: Relation Support — `ormc` Auto-detects Slice Fields

> **Depends on:** [ORMC_HANDLER.md](ORMC_HANDLER.md) and [PLAN.md](PLAN.md) must be completed first.

## Prerequisites

```bash
go install github.com/tinywasm/devflow/cmd/gotest@latest
```

---

## Goal

`ormc` currently skips fields of type `[]Struct` with a log warning.
This plan adds first-class support: when a slice-of-struct field is found,
`ormc` detects the relation type and generates a typed loader function
in the **child's** `_orm.go` — no tags required on the parent.

---

## How It Works — Convention over Configuration

```
type User struct {
    ID    string
    Roles []Role   // no tag needed
}

type Role struct {
    ID     string
    UserID string  `db:"ref=users"`  // FK already declared — ormc reads this
    Name   string
}
```

`ormc` detects:
1. `User.Roles` is `[]Role` — a slice of a known struct
2. `Role` has a field with `db:"ref=users"` — this is the FK back to `User`
3. → generates `ReadAllRoleByUserID` in `role_orm.go`

No tag needed on `User.Roles`. The child struct declares its own FK,
which is the existing pattern.

---

## Decisions

| # | Decision | Rationale |
|---|----------|-----------|
| R1 | Relation detected by: field type is `[]Struct` where `Struct` has a `db:"ref=parentTable"` field | Uses existing `db:"ref=..."` system — zero new concepts |
| R2 | No additional tag on the parent slice field | Minimum tags principle; child already declares the FK |
| R3 | Loader generated in the **child's** `_orm.go`, not the parent's | SRP: child struct owns its own query functions |
| R4 | Loader signature: `ReadAll{Child}By{ParentField}(db *orm.DB, parentID string) ([]*Child, error)` | Typed, consistent with existing `ReadAll{Model}` convention |
| R5 | If no FK found in child struct, skip with `o.log(...)` warning | Cannot generate a loader without knowing the FK column |
| R6 | Many-to-many via junction table: **not in this plan** — requires explicit tag; deferred to `PLAN_MANY_TO_MANY.md` | Complexity; one-to-many covers the most common case first |
| R7 | `ormc` must parse **all structs in scope** before generating, to resolve cross-struct references | Requires a two-pass approach: collect all StructInfo first, then generate |

---

## Architecture

### Two-Pass Generation (change to `Run()`)

```
Pass 1 — Parse all model files → map[structName]StructInfo
Pass 2 — For each StructInfo, resolve slice fields:
          if field.Type = "[]Role" and Role has db:"ref=users"
          → add RelationInfo to Role's StructInfo
          → generate ReadAllRoleByUserID in role_orm.go
```

### New `StructInfo` fields

```go
type StructInfo struct {
    // ... existing fields ...
    Relations []RelationInfo // populated in Pass 2
}

type RelationInfo struct {
    // e.g.:  User has []Role via Role.UserID
    ChildStruct  string // "Role"
    FKField      string // "UserID"
    FKColumn     string // "user_id"
    LoaderName   string // "ReadAllRoleByUserID"
}
```

### Generated code (in `role_orm.go`)

```go
// ReadAllRoleByUserID retrieves all Role records for a given UserID.
// Auto-generated by ormc — relation detected via db:"ref=users" on Role.UserID.
func ReadAllRoleByUserID(db *orm.DB, userID string) ([]*Role, error) {
    return ReadAllRole(db.Query(&Role{}).Where(RoleMeta.UserID).Eq(userID))
}
```

---

## Affected Files

| File | Change |
|------|--------|
| `ormc.go` | Update `Run()` to two-pass: Pass 1 collect all structs, then call `resolveRelations`, then generate |
| `ormc_relations.go` | **New file**: `RelationInfo` type, `collectAllStructs`, `resolveRelations`, `findFKField`, relation loader template |
| `tests/mock_generator_model.go` | Add relation fixture: `MockParent` + `MockChild` with `db:"ref=mock_parents"` |
| `tests/ormc_relations_test.go` | **New file**: test that `ReadAllMockChildByMockParentID` is generated |

---

## Execution Steps

### Step 1 — Create `ormc_relations.go`

New file with build tag `//go:build !wasm`. Contains:
- `RelationInfo` struct
- `(o *Ormc) collectAllStructs(dir string) (map[string]StructInfo, error)`
- `(o *Ormc) resolveRelations(all map[string]StructInfo)`
- `findFKField(child StructInfo, parentTable string) *FieldInfo`
- `relationLoaderTemplate(rel RelationInfo) string`

Add `Relations []RelationInfo` field to `StructInfo` in `ormc.go`:

```go
type RelationInfo struct {
    ChildStruct string // e.g. "Role"
    FKField     string // e.g. "UserID"
    FKColumn    string // e.g. "user_id"
    LoaderName  string // e.g. "ReadAllRoleByUserID"
}

type StructInfo struct {
    // ... existing fields ...
    Relations []RelationInfo
}
```

### Step 2 — Implement `collectAllStructs` in `ormc_relations.go`

`(o *Ormc) collectAllStructs(dir string) (map[string]StructInfo, error)`:
- Walks `o.rootDir`
- Collects all StructInfo from all `model.go`/`models.go` files
- Returns `map[structName]StructInfo`

### Step 3 — Implement `resolveRelations` in `ormc_relations.go`

```go
func (o *Ormc) resolveRelations(all map[string]StructInfo) {
    for parentName, parentInfo := range all {
        for _, field := range parentInfo.SliceFields { // new: []Struct fields collected in ParseStruct
            childInfo, ok := all[field.ElemType]
            if !ok {
                o.log("Warning: slice field", parentName+"."+field.Name,
                    "refers to unknown struct", field.ElemType+"; skipping relation")
                continue
            }
            fkField := findFKField(childInfo, parentInfo.TableName)
            if fkField == nil {
                o.log("Warning: no db:\"ref="+parentInfo.TableName+"\" found in",
                    field.ElemType+"; skipping relation loader")
                continue
            }
            childInfo.Relations = append(childInfo.Relations, RelationInfo{
                ChildStruct: field.ElemType,
                FKField:     fkField.Name,
                FKColumn:    fkField.Column,
                LoaderName:  "ReadAll" + field.ElemType + "By" + fkField.Name,
            })
            all[field.ElemType] = childInfo
        }
    }
}
```

### Step 4 — Update `(o *Ormc) Run()` in `ormc.go` to two-pass

```go
func (o *Ormc) Run() error {
    // Pass 1: collect all structs
    all, err := o.collectAllStructs(o.rootDir)
    if err != nil { return err }

    // Pass 2: resolve cross-struct relations
    o.resolveRelations(all)

    // Pass 3: generate (existing walk logic, now with Relations populated)
    return o.generateAll(all)
}
```

### Step 5 — Update `(o *Ormc) GenerateForFile` in `ormc.go` to emit relation loaders

(Template function `relationLoaderTemplate` lives in `ormc_relations.go`)

For each `info.Relations`, emit:
```go
func ReadAll{Child}By{FK}(db *orm.DB, id string) ([]*{Child}, error) {
    return ReadAll{Child}(db.Query(&{Child}{}).Where({Child}Meta.{FK}).Eq(id))
}
```

### Step 6 — Add test fixtures

```go
// mock_generator_model.go
type MockParent struct {
    ID   string
    Name string
    Kids []MockChild // no tag — relation auto-detected
}

type MockChild struct {
    ID           string
    MockParentID string `db:"ref=mock_parents"`
    Value        string
}
```

### Step 7 — Add `tests/ormc_relations_test.go`

```go
func TestOrmc_RelationLoader(t *testing.T) {
    o := orm.New()
    o.SetRootDir(".")
    // Parse both structs
    parent, _ := o.ParseStruct("MockParent", "mock_generator_model.go")
    child, _  := o.ParseStruct("MockChild",  "mock_generator_model.go")

    all := map[string]orm.StructInfo{
        "MockParent": parent,
        "MockChild":  child,
    }
    o.ResolveRelations(all) // exported for testability

    if len(all["MockChild"].Relations) != 1 {
        t.Fatal("expected 1 relation on MockChild")
    }
    if all["MockChild"].Relations[0].LoaderName != "ReadAllMockChildByMockParentID" {
        t.Errorf("unexpected loader name: %s", all["MockChild"].Relations[0].LoaderName)
    }

    // Generate and check output
    err := o.GenerateForFile([]orm.StructInfo{all["MockChild"]}, "mock_generator_model.go")
    if err != nil { t.Fatal(err) }
    defer os.Remove("mock_generator_model_orm.go")

    content, _ := os.ReadFile("mock_generator_model_orm.go")
    if !strings.Contains(string(content), "ReadAllMockChildByMockParentID") {
        t.Error("relation loader not generated")
    }
}
```

### Step 8 — Run tests

```bash
gotest
```

---

## Acceptance Criteria

| Criterion | Check |
|-----------|-------|
| `[]Struct` field without tag → auto-detected as relation if child has matching `db:"ref=..."` | ✅ |
| No tag required on parent slice field | ✅ |
| Loader generated in child's `_orm.go`, not parent's | ✅ |
| Loader signature: `ReadAll{Child}By{FK}(db *orm.DB, id string)` | ✅ |
| No FK in child → `o.log()` warning + skip (no error) | ✅ |
| Unknown child struct → `o.log()` warning + skip | ✅ |
| `gotest` passes | ✅ |

---

## Out of Scope (deferred)

- Many-to-many via junction table → `PLAN_MANY_TO_MANY.md`
- Eager loading / `Preload()` API
- Nested relations (depth > 1)
