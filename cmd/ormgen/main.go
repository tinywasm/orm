package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"

	tfmt "github.com/tinywasm/fmt"
)

type FieldInfo struct {
	Name       string
	ColumnName string
	IsPK       bool
}

type StructInfo struct {
	Name        string
	TableName   string
	PackageName string
	Fields      []FieldInfo
}

func main() {
	structName := flag.String("struct", "", "Name of the struct to generate ORM code for")
	flag.Parse()

	if *structName == "" {
		log.Fatal("Please provide a struct name using -struct flag")
	}

	goFile := os.Getenv("GOFILE")
	if goFile == "" {
		log.Fatal("GOFILE environment variable is not set. Are you running this via go:generate?")
	}

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, goFile, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Failed to parse file %s: %v", goFile, err)
	}

	var targetStruct *ast.StructType
	var structFound bool

	ast.Inspect(node, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			if typeSpec.Name.Name == *structName {
				if structType, ok := typeSpec.Type.(*ast.StructType); ok {
					targetStruct = structType
					structFound = true
					return false
				}
			}
		}
		return true
	})

	if !structFound {
		log.Fatalf("Struct %s not found in file %s", *structName, goFile)
	}

	tableName := tfmt.Convert(*structName + "s").SnakeLow().String()

	info := StructInfo{
		Name:        *structName,
		TableName:   tableName,
		PackageName: node.Name.Name,
	}

	pkFound := false
	for _, field := range targetStruct.Fields.List {
		if len(field.Names) == 0 {
			continue // Anonymous field, skip for now
		}

		fieldName := field.Names[0].Name
		if !ast.IsExported(fieldName) {
			continue
		}

		colName := tfmt.Convert(fieldName).SnakeLow().String()
		isID, isPK := tfmt.IDorPrimaryKey(tableName, fieldName)

		fieldIsPK := false
		if (isID || isPK) && !pkFound {
			fieldIsPK = true
			pkFound = true
		}

		info.Fields = append(info.Fields, FieldInfo{
			Name:       fieldName,
			ColumnName: colName,
			IsPK:       fieldIsPK,
		})
	}

	generateCode(info, goFile)
}

func generateCode(info StructInfo, sourceFile string) {
	var buf bytes.Buffer

	// File Header
	buf.WriteString(fmt.Sprintf("// Code generated by ormgen; DO NOT EDIT.\n"))
	buf.WriteString(fmt.Sprintf("package %s\n\n", info.PackageName))

	buf.WriteString("import (\n")
	buf.WriteString("\t\"github.com/tinywasm/orm\"\n")
	buf.WriteString(")\n\n")

	// Model Interface Methods
	buf.WriteString(fmt.Sprintf("func (m *%s) TableName() string {\n", info.Name))
	buf.WriteString(fmt.Sprintf("\treturn \"%s\"\n", info.TableName))
	buf.WriteString("}\n\n")

	buf.WriteString(fmt.Sprintf("func (m *%s) Columns() []string {\n", info.Name))
	buf.WriteString("\treturn []string{\n")
	for _, f := range info.Fields {
		buf.WriteString(fmt.Sprintf("\t\t\"%s\",\n", f.ColumnName))
	}
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	buf.WriteString(fmt.Sprintf("func (m *%s) Values() []any {\n", info.Name))
	buf.WriteString("\treturn []any{\n")
	for _, f := range info.Fields {
		buf.WriteString(fmt.Sprintf("\t\tm.%s,\n", f.Name))
	}
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	buf.WriteString(fmt.Sprintf("func (m *%s) Pointers() []any {\n", info.Name))
	buf.WriteString("\treturn []any{\n")
	for _, f := range info.Fields {
		buf.WriteString(fmt.Sprintf("\t\t&m.%s,\n", f.Name))
	}
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	// Metadata Descriptors
	buf.WriteString(fmt.Sprintf("var %sMeta = struct {\n", info.Name))
	buf.WriteString("\tTableName string\n")
	for _, f := range info.Fields {
		buf.WriteString(fmt.Sprintf("\t%s string\n", f.Name))
	}
	buf.WriteString("}{\n")
	buf.WriteString(fmt.Sprintf("\tTableName: \"%s\",\n", info.TableName))
	for _, f := range info.Fields {
		buf.WriteString(fmt.Sprintf("\t%s: \"%s\",\n", f.Name, f.ColumnName))
	}
	buf.WriteString("}\n\n")

	// Typed Read Operations
	buf.WriteString(fmt.Sprintf("func ReadOne%s(qb *orm.QB, model *%s) (*%s, error) {\n", info.Name, info.Name, info.Name))
	buf.WriteString("\terr := qb.ReadOne()\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\treturn nil, err\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn model, nil\n")
	buf.WriteString("}\n\n")

	buf.WriteString(fmt.Sprintf("func ReadAll%s(qb *orm.QB) ([]*%s, error) {\n", info.Name, info.Name))
	buf.WriteString(fmt.Sprintf("\tvar results []*%s\n", info.Name))
	buf.WriteString("\terr := qb.ReadAll(\n")
	buf.WriteString(fmt.Sprintf("\t\tfunc() orm.Model { return &%s{} },\n", info.Name))
	buf.WriteString(fmt.Sprintf("\t\tfunc(m orm.Model) { results = append(results, m.(*%s)) },\n", info.Name))
	buf.WriteString("\t)\n")
	buf.WriteString("\treturn results, err\n")
	buf.WriteString("}\n")

	outName := strings.TrimSuffix(sourceFile, ".go") + "_orm.go"
	err := os.WriteFile(outName, buf.Bytes(), 0644)
	if err != nil {
		log.Fatalf("Failed to write output file: %v", err)
	}
}
