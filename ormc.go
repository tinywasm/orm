//go:build !wasm

package orm

import (
	"errors"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/tinywasm/fmt"
)

type FieldInfo struct {
	Name        string
	ColumnName  string
	Type        FieldType
	Constraints Constraint
	Ref         string
	RefColumn   string
	IsPK        bool
}

type StructInfo struct {
	Name        string
	TableName   string
	PackageName string
	Fields      []FieldInfo
}

// GenerateCodeForStruct reads the Go File and generates the ORM implementations for a given struct name.
// This func is made public to allow easy programmatic testing.
func GenerateCodeForStruct(structName string, goFile string) error {
	if structName == "" {
		return errors.New("Please provide a struct name")
	}

	if goFile == "" {
		return errors.New("goFile path cannot be empty")
	}

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, goFile, nil, parser.ParseComments)
	if err != nil {
		return fmt.Err(err, "Failed to parse file")
	}

	var targetStruct *ast.StructType
	var structFound bool

	ast.Inspect(node, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			if typeSpec.Name.Name == structName {
				if structType, ok := typeSpec.Type.(*ast.StructType); ok {
					targetStruct = structType
					structFound = true
					return false
				}
			}
		}
		return true
	})

	if !structFound {
		return errors.New("Struct not found in file")
	}

	tableName := fmt.Convert(structName + "s").SnakeLow().String()

	info := StructInfo{
		Name:        structName,
		TableName:   tableName,
		PackageName: node.Name.Name,
	}

	pkFound := false
	for _, field := range targetStruct.Fields.List {
		if len(field.Names) == 0 {
			continue // Anonymous field, skip for now
		}

		fieldName := field.Names[0].Name
		if !ast.IsExported(fieldName) {
			continue
		}

		// Field Type mapping
		var fieldType FieldType
		var typeStr string

		if ident, ok := field.Type.(*ast.Ident); ok {
			typeStr = ident.Name
		} else if sel, ok := field.Type.(*ast.SelectorExpr); ok {
			if pkgIdent, ok := sel.X.(*ast.Ident); ok {
				typeStr = pkgIdent.Name + "." + sel.Sel.Name
			}
		} else if arr, ok := field.Type.(*ast.ArrayType); ok {
			if eltIdent, ok := arr.Elt.(*ast.Ident); ok && eltIdent.Name == "byte" {
				typeStr = "[]byte"
			}
		}

		if typeStr == "time.Time" {
			return errors.New("time.Time not allowed, use int64 with tinywasm/time")
		}

		switch typeStr {
		case "string":
			fieldType = TypeText
		case "int", "int32", "int64", "uint", "uint32", "uint64":
			fieldType = TypeInt64
		case "float32", "float64":
			fieldType = TypeFloat64
		case "bool":
			fieldType = TypeBool
		case "[]byte":
			fieldType = TypeBlob
		default:
			log.Printf("Warning: unsupported type %s for field %s. Skipping.", typeStr, fieldName)
			continue
		}

		colName := fmt.Convert(fieldName).SnakeLow().String()
		isID, isPK := fmt.IDorPrimaryKey(tableName, fieldName)

		constraints := ConstraintNone
		var ref, refCol string

		fieldIsPK := false
		if (isID || isPK) && !pkFound {
			fieldIsPK = true
			pkFound = true
			constraints |= ConstraintPK
		}

		if field.Tag != nil {
			tagVal := strings.Trim(field.Tag.Value, "`")
			dbTag := ""
			parts := strings.Split(tagVal, " ")
			for _, p := range parts {
				if strings.HasPrefix(p, "db:\"") {
					dbTag = strings.TrimSuffix(strings.TrimPrefix(p, "db:\""), "\"")
					break
				}
			}

			if dbTag != "" {
				tagParts := strings.Split(dbTag, ",")
				for _, p := range tagParts {
					switch {
					case p == "pk":
						if !fieldIsPK {
							constraints |= ConstraintPK
							fieldIsPK = true
							pkFound = true
						}
					case p == "unique":
						constraints |= ConstraintUnique
					case p == "not_null":
						constraints |= ConstraintNotNull
					case p == "autoincrement":
						if fieldType == TypeText {
							return errors.New("autoincrement not allowed on TypeText")
						}
						constraints |= ConstraintAutoIncrement
					case strings.HasPrefix(p, "ref="):
						refVal := strings.TrimPrefix(p, "ref=")
						refParts := strings.SplitN(refVal, ":", 2)
						ref = refParts[0]
						if len(refParts) > 1 {
							refCol = refParts[1]
						}
					}
				}
			}
		}

		info.Fields = append(info.Fields, FieldInfo{
			Name:        fieldName,
			ColumnName:  colName,
			Type:        fieldType,
			Constraints: constraints,
			Ref:         ref,
			RefColumn:   refCol,
			IsPK:        fieldIsPK,
		})
	}

	return generateCodeFile(info, goFile)
}

func generateCodeFile(info StructInfo, sourceFile string) error {
	buf := fmt.Convert()

	// File Header
	buf.Write(fmt.Sprintf("// Code generated by ormc; DO NOT EDIT.\n"))
	buf.Write(fmt.Sprintf("// NOTE: Schema() and Values() must always be in the same field order.\n"))
	buf.Write(fmt.Sprintf("// String PK: set via github.com/tinywasm/unixid before calling db.Create().\n"))
	buf.Write(fmt.Sprintf("package %s\n\n", info.PackageName))

	buf.Write("import (\n")
	buf.Write("\t\"github.com/tinywasm/orm\"\n")
	buf.Write(")\n\n")

	// Model Interface Methods
	buf.Write(fmt.Sprintf("func (m *%s) TableName() string {\n", info.Name))
	buf.Write(fmt.Sprintf("\treturn \"%s\"\n", info.TableName))
	buf.Write("}\n\n")

	buf.Write(fmt.Sprintf("func (m *%s) Schema() []orm.Field {\n", info.Name))
	buf.Write("\treturn []orm.Field{\n")
	for _, f := range info.Fields {
		typeStr := "orm.TypeText"
		switch f.Type {
		case TypeInt64: typeStr = "orm.TypeInt64"
		case TypeFloat64: typeStr = "orm.TypeFloat64"
		case TypeBool: typeStr = "orm.TypeBool"
		case TypeBlob: typeStr = "orm.TypeBlob"
		}

		var constraintStr []string
		if f.Constraints == ConstraintNone {
			constraintStr = append(constraintStr, "orm.ConstraintNone")
		} else {
			if f.Constraints&ConstraintPK != 0 { constraintStr = append(constraintStr, "orm.ConstraintPK") }
			if f.Constraints&ConstraintUnique != 0 { constraintStr = append(constraintStr, "orm.ConstraintUnique") }
			if f.Constraints&ConstraintNotNull != 0 { constraintStr = append(constraintStr, "orm.ConstraintNotNull") }
			if f.Constraints&ConstraintAutoIncrement != 0 { constraintStr = append(constraintStr, "orm.ConstraintAutoIncrement") }
		}

		buf.Write(fmt.Sprintf("\t\t{Name: \"%s\", Type: %s, Constraints: %s", f.ColumnName, typeStr, strings.Join(constraintStr, " | ")))
		if f.Ref != "" {
			buf.Write(fmt.Sprintf(", Ref: \"%s\"", f.Ref))
		}
		if f.RefColumn != "" {
			buf.Write(fmt.Sprintf(", RefColumn: \"%s\"", f.RefColumn))
		}
		buf.Write("},\n")
	}
	buf.Write("\t}\n")
	buf.Write("}\n\n")

	buf.Write(fmt.Sprintf("func (m *%s) Values() []any {\n", info.Name))
	buf.Write("\treturn []any{\n")
	for _, f := range info.Fields {
		buf.Write(fmt.Sprintf("\t\tm.%s,\n", f.Name))
	}
	buf.Write("\t}\n")
	buf.Write("}\n\n")

	buf.Write(fmt.Sprintf("func (m *%s) Pointers() []any {\n", info.Name))
	buf.Write("\treturn []any{\n")
	for _, f := range info.Fields {
		buf.Write(fmt.Sprintf("\t\t&m.%s,\n", f.Name))
	}
	buf.Write("\t}\n")
	buf.Write("}\n\n")

	// Metadata Descriptors
	buf.Write(fmt.Sprintf("var %sMeta = struct {\n", info.Name))
	buf.Write("\tTableName string\n")
	for _, f := range info.Fields {
		buf.Write(fmt.Sprintf("\t%s string\n", f.Name))
	}
	buf.Write("}{\n")
	buf.Write(fmt.Sprintf("\tTableName: \"%s\",\n", info.TableName))
	for _, f := range info.Fields {
		buf.Write(fmt.Sprintf("\t%s: \"%s\",\n", f.Name, f.ColumnName))
	}
	buf.Write("}\n\n")

	// Typed Read Operations
	buf.Write(fmt.Sprintf("func ReadOne%s(qb *orm.QB, model *%s) (*%s, error) {\n", info.Name, info.Name, info.Name))
	buf.Write("\terr := qb.ReadOne()\n")
	buf.Write("\tif err != nil {\n")
	buf.Write("\t\treturn nil, err\n")
	buf.Write("\t}\n")
	buf.Write("\treturn model, nil\n")
	buf.Write("}\n\n")

	buf.Write(fmt.Sprintf("func ReadAll%s(qb *orm.QB) ([]*%s, error) {\n", info.Name, info.Name))
	buf.Write(fmt.Sprintf("\tvar results []*%s\n", info.Name))
	buf.Write("\terr := qb.ReadAll(\n")
	buf.Write(fmt.Sprintf("\t\tfunc() orm.Model { return &%s{} },\n", info.Name))
	buf.Write(fmt.Sprintf("\t\tfunc(m orm.Model) { results = append(results, m.(*%s)) },\n", info.Name))
	buf.Write("\t)\n")
	buf.Write("\treturn results, err\n")
	buf.Write("}\n")

	outName := fmt.Convert(sourceFile).TrimSuffix(".go").String() + "_orm.go"
	return os.WriteFile(outName, buf.Bytes(), 0644)
}

// RunOrmcCLI is the entry point for the CLI tool.
func RunOrmcCLI() {
	cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("Failed to get working directory: %v", err)
	}

	foundAny := false

	err = filepath.Walk(cwd, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() {
			dirName := info.Name()
			if dirName == "vendor" || dirName == ".git" || dirName == "testdata" {
				return filepath.SkipDir
			}
			return nil
		}

		fileName := info.Name()
		if fileName == "model.go" || fileName == "models.go" {
			fset := token.NewFileSet()
			node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
			if err != nil {
				return nil // Skip unparseable files
			}

			for _, decl := range node.Decls {
				if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.TYPE {
					for _, spec := range genDecl.Specs {
						if typeSpec, ok := spec.(*ast.TypeSpec); ok {
							if _, ok := typeSpec.Type.(*ast.StructType); ok {
								err := GenerateCodeForStruct(typeSpec.Name.Name, path)
								if err != nil {
									log.Printf("Failed to generate code for %s in %s: %v", typeSpec.Name.Name, path, err)
								} else {
									foundAny = true
								}
							}
						}
					}
				}
			}
		}

		return nil
	})

	if err != nil {
		log.Fatalf("Error walking directory: %v", err)
	}

	if !foundAny {
		log.Fatal("No models found")
	}
}
