//go:build !wasm

package orm

import (
	"flag"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"

	"github.com/tinywasm/fmt"
)

type FieldInfo struct {
	Name       string
	ColumnName string
	IsPK       bool
}

type StructInfo struct {
	Name        string
	TableName   string
	PackageName string
	Fields      []FieldInfo
}

// GenerateCodeForStruct reads the Go File and generates the ORM implementations for a given struct name.
// This func is made public to allow easy programmatic testing.
func GenerateCodeForStruct(structName string, goFile string) {
	if structName == "" {
		log.Fatal("Please provide a struct name")
	}

	if goFile == "" {
		log.Fatal("goFile path cannot be empty")
	}

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, goFile, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Failed to parse file %s: %v", goFile, err)
	}

	var targetStruct *ast.StructType
	var structFound bool

	ast.Inspect(node, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			if typeSpec.Name.Name == structName {
				if structType, ok := typeSpec.Type.(*ast.StructType); ok {
					targetStruct = structType
					structFound = true
					return false
				}
			}
		}
		return true
	})

	if !structFound {
		log.Fatalf("Struct %s not found in file %s", structName, goFile)
	}

	tableName := fmt.Convert(structName + "s").SnakeLow().String()

	info := StructInfo{
		Name:        structName,
		TableName:   tableName,
		PackageName: node.Name.Name,
	}

	pkFound := false
	for _, field := range targetStruct.Fields.List {
		if len(field.Names) == 0 {
			continue // Anonymous field, skip for now
		}

		fieldName := field.Names[0].Name
		if !ast.IsExported(fieldName) {
			continue
		}

		colName := fmt.Convert(fieldName).SnakeLow().String()
		isID, isPK := fmt.IDorPrimaryKey(tableName, fieldName)

		fieldIsPK := false
		if (isID || isPK) && !pkFound {
			fieldIsPK = true
			pkFound = true
		}

		info.Fields = append(info.Fields, FieldInfo{
			Name:       fieldName,
			ColumnName: colName,
			IsPK:       fieldIsPK,
		})
	}

	generateCodeFile(info, goFile)
}

func generateCodeFile(info StructInfo, sourceFile string) {
	buf := fmt.Convert()

	// File Header
	buf.Write(fmt.Sprintf("// Code generated by ormc; DO NOT EDIT.\n"))
	buf.Write(fmt.Sprintf("package %s\n\n", info.PackageName))

	buf.Write("import (\n")
	buf.Write("\t\"github.com/tinywasm/orm\"\n")
	buf.Write(")\n\n")

	// Model Interface Methods
	buf.Write(fmt.Sprintf("func (m *%s) TableName() string {\n", info.Name))
	buf.Write(fmt.Sprintf("\treturn \"%s\"\n", info.TableName))
	buf.Write("}\n\n")

	buf.Write(fmt.Sprintf("func (m *%s) Columns() []string {\n", info.Name))
	buf.Write("\treturn []string{\n")
	for _, f := range info.Fields {
		buf.Write(fmt.Sprintf("\t\t\"%s\",\n", f.ColumnName))
	}
	buf.Write("\t}\n")
	buf.Write("}\n\n")

	buf.Write(fmt.Sprintf("func (m *%s) Values() []any {\n", info.Name))
	buf.Write("\treturn []any{\n")
	for _, f := range info.Fields {
		buf.Write(fmt.Sprintf("\t\tm.%s,\n", f.Name))
	}
	buf.Write("\t}\n")
	buf.Write("}\n\n")

	buf.Write(fmt.Sprintf("func (m *%s) Pointers() []any {\n", info.Name))
	buf.Write("\treturn []any{\n")
	for _, f := range info.Fields {
		buf.Write(fmt.Sprintf("\t\t&m.%s,\n", f.Name))
	}
	buf.Write("\t}\n")
	buf.Write("}\n\n")

	// Metadata Descriptors
	buf.Write(fmt.Sprintf("var %sMeta = struct {\n", info.Name))
	buf.Write("\tTableName string\n")
	for _, f := range info.Fields {
		buf.Write(fmt.Sprintf("\t%s string\n", f.Name))
	}
	buf.Write("}{\n")
	buf.Write(fmt.Sprintf("\tTableName: \"%s\",\n", info.TableName))
	for _, f := range info.Fields {
		buf.Write(fmt.Sprintf("\t%s: \"%s\",\n", f.Name, f.ColumnName))
	}
	buf.Write("}\n\n")

	// Typed Read Operations
	buf.Write(fmt.Sprintf("func ReadOne%s(qb *orm.QB, model *%s) (*%s, error) {\n", info.Name, info.Name, info.Name))
	buf.Write("\terr := qb.ReadOne()\n")
	buf.Write("\tif err != nil {\n")
	buf.Write("\t\treturn nil, err\n")
	buf.Write("\t}\n")
	buf.Write("\treturn model, nil\n")
	buf.Write("}\n\n")

	buf.Write(fmt.Sprintf("func ReadAll%s(qb *orm.QB) ([]*%s, error) {\n", info.Name, info.Name))
	buf.Write(fmt.Sprintf("\tvar results []*%s\n", info.Name))
	buf.Write("\terr := qb.ReadAll(\n")
	buf.Write(fmt.Sprintf("\t\tfunc() orm.Model { return &%s{} },\n", info.Name))
	buf.Write(fmt.Sprintf("\t\tfunc(m orm.Model) { results = append(results, m.(*%s)) },\n", info.Name))
	buf.Write("\t)\n")
	buf.Write("\treturn results, err\n")
	buf.Write("}\n")

	outName := fmt.Convert(sourceFile).TrimSuffix(".go").String() + "_orm.go"
	err := os.WriteFile(outName, buf.Bytes(), 0644)
	if err != nil {
		log.Fatalf("Failed to write output file: %v", err)
	}
}

// RunOrmcCLI is the entry point for the CLI tool.
func RunOrmcCLI() {
	structName := flag.String("struct", "", "Name of the struct to generate ORM code for")
	flag.Parse()

	if *structName == "" {
		log.Fatal("Please provide a struct name using -struct flag")
	}

	goFile := os.Getenv("GOFILE")
	if goFile == "" {
		log.Fatal("GOFILE environment variable is not set. Are you running this via go:generate?")
	}

	GenerateCodeForStruct(*structName, goFile)
}
